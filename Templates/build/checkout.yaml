---
parameters:
  - name: buildType
    default: 'c'
  - name: buildType_W
    default: 'c_windows'
  - name: sourcePath
    default: '.'
  - name: dotNetProjects

steps:
  - ${{ if eq(parameters.buildType, 'c') }}:
      - bash: |
            #!/bin/bash
            GREEN="\e[1;32m"
            DEFAULT="\e[0m"
            RED="\033[31m"
            BLUE="\e[1;36m"
            if [[ ${{ parameters.sourcePath }} == '.' ]] ; then
                echo -e "${GREEN} [+] Path: ${{ parameters.sourcePath }}"
                CBP_PATH=$(find ./ -name C-Fontes -type d | head -1)
                cd $CBP_PATH
            else
                  echo -e "${GREEN} [+] Path: ${{ parameters.sourcePath }}"
                  cd ${{ parameters.sourcePath }}
            fi

            CBP_FILE=$(ls *.cbp | head -1)
            echo -e "${BLUE}###############################################"
            echo -e "${GREEN}[+] Gerando makefile para compilação do $CBP_FILE..."
            if cbp2make -in $CBP_FILE -out Makefile; then
                    echo -e "${GREEN}[+] Makefile gerado com sucesso..."
                    echo -e "${BLUE}###############################################"
            else
                    echo -e "${RED}[-] Falha ao gerar Makefile"
                    echo -e "${BLUE}###############################################${DEFAULT}"
                    exit 1
            fi
            sleep 2

            echo -e "${GREEN}[+] Ajustando parametros do Makefile..."
            sed -i 's/^CFLAGS =/CFLAGS = -std=c++11 -fpermissive/' Makefile
            echo -e "${BLUE}###############################################"

            echo -e "${GREEN}[+] Realizando compilação..."
            make clean && make so_x86

            mkdir artifact
            cp -r bin/Linux/Release/x86/ artifact/
            sed -i -e 's/m32/m64/g' -e 's/CFLAGS =/CFLAGS = -fPIC /' Makefile
            make clean_so_x86 && make so_x64 || exit 1
            cp -r bin/Linux/Release/x64/ artifact/
            make clean
            echo -e "${BLUE}###############################################"

            for ar in x86 x64 ; do
              if ! type artifact/$ar/* >/dev/null; then
                echo -e "${RED}[-] Falha ao realizar compilação em $ar!"
                echo -e "${BLUE}###############################################${DEFAULT}"
                exit 1
              else
                echo -e "${GREEN}[+] Compilação realizada com sucesso - $ar!"
                ls -1 artifact/$ar
                echo -e "${BLUE}###############################################${DEFAULT}"
              fi
            done
            echo -e "${BLUE}#################### FIM ###########################${DEFAULT}"
            artifactPath="/tmp/$(Build.BuildId)-${{ parameters.buildType }}/artifact"
            mkdir -p $artifactPath/$(Build.Repository.Name)
            mv artifact/* $artifactPath/$(Build.Repository.Name)/
            echo "##vso[task.setvariable variable=Artifact]$artifactPath"
        displayName: 'C Build'

  - ${{ if eq(parameters.buildType, 'c_windows') }}:
      - pwsh: |
            param (
            [Parameter(Mandatory=$true)]
            [ValidateSet(32,64)]
            [int]$Version
            )

            # Definir o caminho base para a pasta mingw
            $mingwBasePath = "C:\Compiladores\mingw"
            
            # Remover a pasta C:\Compiladores\mingw se ela existir
            if (Test-Path $mingwBasePath) {
                Remove-Item $mingwBasePath -Recurse -Force
                Write-Host "Pasta antiga $mingwBasePath removida."
            }
            
            # Definir o caminho do compilador com base no parâmetro
            $mingwPath = "C:\Compiladores\mingw$Version"
            
            # Verificar se o caminho do compilador existe
            if (-not (Test-Path $mingwPath)) {
                Write-Host "Caminho do compilador não encontrado: $mingwPath"
                exit
            }
            
            # Renomear a pasta do compilador para C:\Compiladores\mingw
            Copy-Item -Recurse $mingwPath $mingwBasePath
            Write-Host "Pasta do compilador renomeada para $mingwBasePath"
            
            # Executar comandos no CodeBlocks se a versão for 64
            # Caminho para o executável do CodeBlocks
            $codeBlocksPath = "C:\Program Files\CodeBlocks\codeblocks.exe"
            $projectFile = "API_PertoCoinAcceptor.cbp"
            $projectPath = "C:\Users\KevinJanuariodaSilva\Documents\PERTO\API_CoinAcceptor\Trunk\C-Fontes\"

            # Executar comandos no CodeBlocks
            Push-Location $projectPath
            & $codeBlocksPath --clean $projectFile
            Start-Sleep -Seconds 15
            if ($Version -eq 64) {
                Write-Host "Versão 64 bits selecionada"
                & $codeBlocksPath --build $projectFile --target "DLL x64"
                #Rename-Item $mingwBasePath $mingwPath
                Pop-Location
            } else {
                Write-Host "Versão 32 bits selecionada"
                & $codeBlocksPath --build $projectFile --target "DLL x86"
                #Rename-Item $mingwBasePath $mingwPath
                Pop-Location
            }

  - ${{ if eq(parameters.buildType, 'dotnet') }}:
      - bash: |
            artifactPath="/tmp/$(Build.BuildId)-${{ parameters.buildType }}"
            echo "[+] Criando diretorio $artifactPath"
            mkdir -p $artifactPath/artifact/$(Build.Repository.Name)
            mkdir $artifactPath-temp
            echo "##vso[task.setvariable variable=Artifact]$artifactPath"
            echo "##vso[task.setvariable variable=ArtifactTemp]$artifactPath-temp"
        displayName: CreateOutputDir

      - task: DotNetCoreCLI@2
        displayName: 'Dotnet Build'
        inputs:
          command: 'build'
          projects: '**/*.${{ parameters.dotNetProjects }}'
          modifyOutputPath: true
          arguments: '--output $(Artifact)-temp'

      - task: ArchiveFiles@2
        displayName: 'Zip Repository Content'
        inputs:
          rootFolderOrFile: '$(Artifact)-temp'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Artifact)/artifact/$(Build.Repository.Name)/$(Build.Repository.Name)-$(Build.BuildId).zip'
          replaceExistingArchive: true
